# 1. 소프트웨어 개발 수명주기 모델
## Q. 소프트웨어 개발 수명주기에서의 소프트웨어 개발 활동과 테스트 활동의 관계를 설명하시오
- 모든 개발 활동은 그에 상응하는 한 개 이상의 테스트 활동이 있다
- 각 테스트 레벨은 그 레벨에 맞는 구체적인 서로 다른 독립적인 목적을 가진다
- 주어진 테스트 레벨에 맞는 테스트 분석과 설계는 상응하는 개발 활동이 이루어지고 있는 동안 시작
- Early Testing 으로 결함 식별하고 수정 비용을 줄일 수 있다

<pre>
<code>
- 정적 테스팅 : 리뷰, 코드 분석과 같이 명세, 구현, 개발 단계에서 컴포넌트나 시스템 테스팅
- 동적 테스팅 : 컴포넌트나 시스템 SW를 실행하면서 수행하는 테스팅

[정적 테스팅 : 테스트 용이성 평가]			[동적 테스팅]
요구분석								인수 테스트
	비즈니스 설계					시스템 테스트
		시스템 설계			통합 테스트
			코딩		컴포넌트 테스트
</code>
</pre>

1) 순차적 개발 모델
- 개발 프로세스의 모든 단계는 이전 단계가 완료될 때 시작되어야 한다 
- 요구사항을 명확히 선언해야 하고, 변화가 없어야 한다
- EX. 폭포수 모델 프로세스

2) 점진적 개발 모델
- 요구사항 정의, 시스템의 설계, 구축, 테스팅을 조각으로 나눠서 진행
- 소프트웨어의 기능이 점진적으로 늘어남
- 릴리스 파이프라인에 속한 여러 테스트 레벨에 대해 상당한 자동화 구현 요구
- 리그레션 테스팅의 중요성 증가

3) 반복적 개발 모델
- 기능 집합을 종종 고정된 기간의 일련의 주기 안에서 같이 명시, 설계, 구축, 테스트할 때 발생
- 테스트 레벨을 중첩하거나 반복적으로 적용하는 경우가 많아 진다
- 릴리스 파이프라인에 속한 여러 테스트 레벨에 대해 상당한 자동화 구현 요구
- EX. Rational Unified Process, Scrum, Kanban, Spiral

## Q. 소프트웨어 개발 수명주기 모델을 프로젝트 정황과 제품 특성에 따라 수정해야 하는 이유를 설명하시오
1) 시스템의 제품 리스크 차이
2) 많은 사업부가 프로젝트나 프로그램의 일부일 수 있음 (순차적 + 에자일 개발의 조합)
3) 제품의 짧은 출시 기간 (테스트 레벨에서 테스트 유형의 통합 및 테스트 레벨 병합)

- 프로젝트의 정황과 제품의 특성 
: 프로젝트의 목표, 개발 대상 제품의 유형, 비즈니스 특성 (EX. 출시 시기), 식별된 제품 및 프로젝트 리스크, 팀내외적인 요소 (EX. 조직의 문화적 차이) 등

- 프로젝트의 정황에 따라 테스트 레벨과 테스트 활동을 조합하거나 조정해야 할 경우 
EX. 상용 소프트웨어 (COTS) 를 큰 시스템에 통합하는 경우, 구매자가 상호운용성 테스팅을 시스템 통합 테스팅 레벨의 끝 + 인수 테스트 레벨 에서 실행

- 소프트웨어 개발 수명주기 모델도 조합 가능
EX. 백엔드 테스팅에는 V-모델 사용 + 프론트엔드 테스팅에는 에자일 개발 모델

---

# 2. 테스트 레벨
## Q. 목적, 테스트 베이시스, 테스트 대상, 대표적 결함과 장애, 접근법과 책임의 관점에서 다양한 테스트 레벨을 비교하시오
A. 테스트 레벨 = 함께 분류되고 관리되는 테스트 활동의 집합

### 1) 컴포넌트 테스팅
* 의미
	단위 테스팅 = 모듈 테스팅 = 개별적으로 테스트할 수 있는 컴포넌트에 초점을 맞춤
* 목적
	- 리스크 완화
	- 컴포넌트의 기능과 비기능 동작이 설계 및 명세와 일치하는지 여부 판단
	- 컴포넌트 품질 수준에 대한 자신감 획득
	- 컴포넌트에 존재하는 결함 발견
	- 다음 단계로의 결함 전이 방지
* 커버 가능 범위
	- 기능 (EX. 연산의 정확성)
	- 비기능 (EX. 메모리 누수 탐지, 연산 속도)
	- 구조적 속성 (EX. 결정 테스팅)
* 테스트 베이시스
	- 상세 설계
	- 코드
	- 데이터 모델
	- 컴포넌트 명세
* 테스트 대상
	- 컴포넌트, 단위, 모듈
	- 코드 및 데이터 구조 (EX. 클래스, 구조체 등)
	- 클래스
	- 데이터베이스 모듈
* 대표적인 결함 및 장애
	- 잘못된 기능 (EX. 설계 명세의 설명과 다름)
	- 데이터 흐름 문제
	- 잘못된 코드 및 논리
* 구체적인 접근법과 책임
	- 주로 개발자가 수행함
	- 컴포넌트 코드를 작성하고 테스트를 작성하고 실행하는 경우
	- 자동화된 컴포넌트 테스트 케이스를 작성하는 경우

### 2) 통합 테스팅
* 의미
	컴포넌트나 시스템 간의 상호작용에 초점을 맞춰서 진행
* 목적
	- 리스크 완화
	- 인터페이스의 기능과 비기능 동작이 설계 및 명세와 일치 여부 판단
	- 인터페이스 품질 수준에 대한 자신감 획득
	- 결함 발견 (인터페이스 자체 또는 컴포넌트나 시스템에 존재 가능)
	- 다음 단계로의 결함 전이 방지
* 구분
	- 컴포넌트 통합 테스팅 : 통합된 컴포넌트 간의 상호운용성과 인터페이스 초점
	- 시스템 통합 테스팅 : 시스템, 패키지, 마이크로 서비스 간의 상호운용성과 인터페이스 초점 (기존에 존재하는 시스템과 연동)
* 테스트 베이시스
	- 소프트웨어 및 시스템 설계
	- 인터페이스 및 통신 프로토콜 명세
	- 유스케이스
	- 컴포넌트나 시스템 레벨의 아키텍처
	- 워크플로우
	- 외부 인터페이스 정의서
* 테스트 대상
	- 서브시스템
	- 데이터베이스
	- 인프라
	- 인터페이스
	- API
	- 마이크로서비스	
* 대표적인 결함 및 장애
	[컴포넌트 통합 테스팅]
	- 잘못된 데이터, 누락된 데이터, 잘못된 데이터 인코딩
	- 잘못된 인터페이스 콜 순서나 타이밍
	- 인터페이스 불일치
	- 컴포넌트 간의 통신 장애
	- 컴포넌트 간의 통신 실패처리 누락 및 오류
	- 컴포넌트 간 주고 받는 데이터의 의미, 단위, 경계에 대한 잘못된 가정

	[시스템 통합 테스팅]
	- 시스템 간의 일관적이지 않은 메시지 구조
	- 잘못된 데이터, 누락된 데이터, 잘못된 데이터 인코딩
	- 인터페이스 불일치
	- 시스템 간의 통신 장애
	- 시스템 간의 통신 실패 처리 누락 및 오류
	- 시스템 간 주고 받는 데이터의 의미, 단위, 경계에 대한 잘못된 가정
	- 필수 보안 규정 준수 실패
* 구체적인 접근법과 책임
	가능한 점진적으로 진행해야 한다 (한번에 몇 개의 컴포넌트나 시스템만 추가)
	[컴포넌트 통합 테스팅]
	- 모듈 A와 모듈 B를 통합하는 경우, 모듈 간의 커뮤니케이션에 집중
	- 컴포넌트 테스팅에서 커버했어야 할 개별 모듈의 기능에 집중하면 X
	- 개발자의 책임인 경우 많음

	[시스템 통합 테스팅]
	- 시스템 X와 시스템 Y를 통합하는 경우, 시스템 간의 커뮤니케이션에 집중
	- 시스템 테스팅에서 커버했어야 할 개별 시스템의 기능에 집중하면 X
	- 테스터의 책임인 경우 많음 (시스템 아키텍처를 이해하고 통합 계획에 참여해야 함)
	

### 3) 시스템 테스팅
* 의미
	- 전체 시스템 또는 제품의 동작이나 능력에 관심을 가진다
	- 시스템이 수행할 엔드-투-엔드 (End-to-End) 작업과 그런 작업을 수행할 때 나타나는 비기능 동작을 고려한다
	
* 목적
	- 리스크 완화
	- 시스템의 기능/비기능 동작이 설계 및 명시된 대로 이루어지는지 검증
	- 완성된 시스템이 기대한 대로 동작하는지 확인
	- 전체 시스템 품질에 대한 자신감 획득
	- 결함 발견
	- 결함이 상위 테스트 레벨이나 생산 단계로의 전이 방지

* 테스트 베이시스
	- 시스템 및 소프트웨어 요구사항 명세 (기능 / 비기능)
	- 리스크 분석 보고서
	- 유즈케이스
	- 에픽과 사용자 스토리
	- 시스템 동작 모델
	- 상태 다이어그램
	- 시스템 및 사용자 메뉴얼

* 테스트 대상
	- 애플리케이션
	- 하드웨어 / 소프트웨어 시스템
	- 운영 시스템
	- 테스트 대상 시스템
	- 시스템 설정과 설정 데이터

* 일반적인 결함과 장애
	- 잘못된 연산
	- 시스템의 잘못되거나 예상치 못한 기능 / 비기능 동작
	- 시스템 내 잘못된 제어 및 데이터 흐름
	- E2E 기능 작업 수행 실패
	- 시스템 환경에서 시스템의 정상 동작 실패
	- 시스템 및 사용자 매뉴얼대로의 시스템 동작 실패
* 구체적인 접근법과 역할
	- 테스트 대상 시스템의 특성에 가장 잘 맞는 기법을 사용해야 한다
	(EX. 기능 동작이 비즈니스 규칙에서 설명하는 것과 맞는지 검증하기 위해서는 결정 테이블을 생성할 수 있다)
	- 명세에 과도하게 의존하는 독립적인 테스터가 수행한다
	- 명세 결함은 기대 시스템 동작에 대한 이해 부족이나 의견 불일치 발생 가능

### 4) 인수 테스팅
* 의미
	- 시스템을 배포하거나 고객이 사용할 준비가 어느 정도 됐는지 평가
	- 결함이 발견될 수 있지만 결함 발견이 목적이 아닌 경우가 많음
	- 많은 결함 발생 시 심각한 프로젝트 리스크로 인식하는 경우도 있음
* 목적
	- 전체 시스템의 품질에 대한 자신감 획득
	- 완성된 시스템이 기대한 대로 동작하는지 확인
	- 시스템의 기능/비기능 동작이 명세대로 동작하는지 검증
* 인수 테스팅의 대표적인 형태
	1. 사용자 인수 테스팅
		- 실제 / 시뮬레이션된 운영 환경에서 예정된 사용자가 사용하기 얼마나 적합한지 확인
		- 사용자가 필요에 따라 최소한의 어려움, 비용, 리스크 등으로 요구사항을 충족하며 비즈니스 프로세스를 수행할 수 있다는 자신감 획득 목표

	2. 운영 인수 테스팅
		- 운영자 또는 시스템 관리 직원에 의해 수행됨
		- 생산 환경에서 일어나고, 운영 측면에 집중되어 있음
		- 운영자 또는 시스템 관리자가 예외적이고 어려운 조건에서도 사용자를 위한 시스템을 정상적으로 유지할 수 있다는 자신감 획득 목표
		- EX. 백업 및 복원 테스팅 / 설치, 삭제, 업그레이드 / 긴급 복구 / 사용자 관리 / 유지보수 작업 / 데이터 로딩 및 이관 작업 / 보완 취약점 확인 / 성능 테스팅
		- [테스트 베이시스] 백업 및 복원 절차, 긴급 복구 절차, 비기능 요구사항, 운영 문서, 배포 및 설치 지침, 성능 목표, 데이터베이스 패키지, 보안 표준 또는 규정

	3. 계약 및 규제 인수 테스팅
		[계약 인수]
		- 주문 개발 소프트웨어의 생산을 위한 계약서에 명시된 인수 조건을 가지고 수행
		- 독립적인 테스터가 수행함
		
		[규제 인수]
		- 정부, 법적, 안전 규제 등과 같이 준수해야 하는 모든 규제를 가지고 수행
		- 사용자나 독립적인 테스터가 수행함
		- 규제 기관이 결과에 대한 실사나 감사 진행

	4. 알파 및 베타 테스팅
		사용 가능 여부 확인 + 시스템 사용 조건 및 환경과 관련된 결함 발견 목표
		[알파 테스팅]
		- 개발 조직의 현장에서 개발팀이 아닌 신규 혹은 기존 고객이나 운영자, 독립적 테스트팀이 수행

		[베타 테스팅]
		- 신규 혹은 기존 고객이나 운영자가 자신의 환경에서 수행
		
* 테스트 베이시스
	- 비즈니스 프로세스
	- 사용자 또는 비즈니스 요구사항
	- 규제, 법적 계약, 표준
	- 유즈케이스 및 사용자 스토리
	- 시스템 요구사항
	- 시스템 또는 사용자 문서
	- 설치 절차
	- 리스크 분석 보고서

* 테스트 대상
	- 테스트 대상 시스템
	- 시스템 설정과 설정 데이터
	- 완전히 통합된 시스템의 비즈니스 프로세스
	- 복원 시스템이나 비즈니스 연속성 및 긴급 복구 테스팅을 위한 핫 사이트
	- 운영 및 유지보수 프로세스
	- 양식
	- 보고서
	- 기존 및 전환된 생산 데이터

* 일반적인 결함과 장애
	- 비즈니스나 사용자 요구사항을 충족하지 못하는 시스템 워크플로우
	- 잘못 구현된 비즈니스 규칙
	- 계약 혹은 규제 요구사항을 충족하지 못하는 시스템
	- 보안 취약성, 많은 부하가 걸렸을 때 성능 효율성 저하, 지원 대상 플랫폼상에서의 잘못된 운영 등과 같은 비기능 장애

* 구체적인 접근법과 역할
	- 고객, 비즈니스 사용자, 제품 소유자, 시스템 운영자, 기타 이해관계자 참여
	- <B> 인수 테스팅은 마지막 테스트 레벨인 경우가 많지만, 그렇지 않은 경우도 있음 </B>
		- 상용 소프트웨어 제품에 대한 인수 테스팅은 그것이 설치되거나 통합될 때
		- 신규 기능 개선 사항에 대한 인수 테스팅은 시스템 테스팅 전
		- 반복적 개발의 경우 인수 테스팅은 다음 반복 주기의 시작

---

# 3. 테스트 유형
테스트 유형 = 특정 테스트 목적을 위해 소프트웨어 시스템이나 시스템의 일부 특정 속성을 테스트하는 활동의 집합

## Q. 기능, 비기능, 화이트박스 테스팅을 비교하시오 (+ 목적)
- [블랙박스 테스팅]
	- 기능 (EX. 계산 정확도, 특정 값을 넣었을 때 원하는 값이 나오는지)
	모든 테스트 레벨에서 가능함 (단, 각 레벨마다 관심사항은 다름)
		* 기능 성숙도 (기능이 요구사항에 잘 맞게 구현되었는지)
		* 기능 정확도 (기능이 얼마나 정확한지)
		* 기능 타당성 (기능이 요구에 적합한지)

	- 비기능 (EX. 성능, 특정 값을 넣었을 때 결과가 나오는 데 시간이 오래 걸리는지)
	모든 테스트 레벨에서 가능함 (가능한 빨리 해야함 & 프로젝트 초반에 해야 함)
		* 기능 적합성
		* 수행 효율성
		* 호환성
		* 유용성
		* 신뢰도
		* 보안
		* 유지관리성
		* 이동성

- [화이트박스 테스팅]
	- 시스템의 내부 구조나 구현을 기반으로 테스트를 도출한다
	- 내부 구조로는 <B> 코드, 아키텍처, 워크플로우, 시스템 내 데이터 플로우</B> 가 있다
	- 마찬가지로 모든 테스트 레벨에서 가능함
- [변경 관련 테스팅]
	- 확인 테스팅
		- 결함이 수정된 후 이 결함으로 인해 불합격했던 모든 테스트 케이스를 새로운 소프트웨어 버전에서 재실행함
		- 모든 테스트 레벨에서 가능함
	- 리그레션 테스팅
		- 코드의 특정 부분에 대한 변경이 의도치 않게 코드의 다른 부분에 영향을 줄 수 있기 때문에 전체 테스트 케이스를 다시 테스팅하는 방법
		- 여러 번 반복 수행되며 대개는 변화가 없기 때문에 자동화에 적합함
		- 모든 테스트 레벨에서 가능함
	
## Q. 기능, 비기능, 화이트박스 테스트가 모든 테스트 레벨에서 이루어질 수 있는가?
- 모든 소프트웨어가 모든 레벨에 모든 테스트 유형을 적용해야 하는 것은 아니다
- 하지만 각 레벨에서 가능한 테스트 유형을 수행하는 것이 중요
- 특히 해당 테스트 유형이 처음으로 발생하는 첫 레벨에서 수행하는 것이 중요

|  | 기능 | 비기능 | 화이트박스 | 변경 관련 테스팅 |
|:----------:|:----------:|:----------:|:----------:|:----------:|
| 컴포넌트 테스팅 | 이자 계산 어떻게 해야하는지 | 이자 계산을 위한 CPU CYCLE 횟수 | 금융 계산을 수행하는 모든 컴포넌트에 대한 완벽한 구문 및 결정 커버리지를 달성하기 위한 테스트 설계 | 각 컴포넌트를 위한 자동 리그레션 테스트가 구축되고 지속적인 통합 프레임워크에 포함 |
| 컴포넌트 통합 테스팅 | UI의 계정 정보가 어떻게 비즈니스 로직으로 전달되는지  | UI에서 비즈니스 로직으로 전달되는 데이터로 인한 버퍼 오버플로우 취약성을 위한 보안 테스트 설계 | UI의 각 화면이 다음 화면과 비즈니스 로직을 기반으로 데이터를 어떻게 전달하는지 확인하기 위한 테스트 설계 | 인터페이스 관련 결함 수정이 코드 저장소에 들어왔을 때 해당 수정을 확인하기 위한 테스트 설계 |
| 시스템 통합 테스팅 | 시스템이 외부 서비스를 사용해서 계좌 소유주의 신용 점수를 확인하는 방법 | 신용 점수 서비스가 응답하지 않을 때 시스템의 강건성을 평가하기 위한 신뢰성 테스트 설계 | 신용 점수 서비스로 보내는 모든 조회 유형을 실행하기 위한 테스트 설계 | 신용 점수 서비스에 대한 지속적인 개발의 일환으로 해당 서비스와 상호작용하는 애플리케이션에 대한 테스트를 매일 재실행 |
| 시스템 테스팅 | 계좌 소유주가 어떻게 자신의 예금 통장에 신용한도를 부여할 수 있는지 | UI가 모든 브라우저와 모바일 기기에서 제대로 동작하는지 이식성 테스트 설계 | 신용 한도 신청 도중 순차적으로 거치게 되는 웹페이지를 커버하기 위한 테스트 설계 | 특정 워크플로우에 속하는 화면 중 하나만 변경되더라도 해당 워크플로우에 대한 모든 테스트 실행 |
| 인수 테스팅 | 은행이 신용 한도를 승인하거나 거절하는 방법 | 은행 신용 처리 인터페이스에 장애인의 접근성을 평가하는 사용성 테스트 설계 | 은행 간 이체에서 지원하는 모든 금융 데이터 파일 구조와 값 범위를 커버하기 위한 테스트 설계 | 인수 테스팅에 발견된 결함이 수정되면 기존에 불합격했던 모든 테스트를 재실행

---

# 4. 유지보수 테스팅
## Q. 유지보수 테스팅이 필요한 상황은 언제인가?
- 필요 이유
	- 유지보수는 배포된 소프트웨어와 시스템에 대한 변경이 필연적으로 발생하기 때문에 운영 중 발견한 결함 수정, 신규 기능 추가, 기존 기능의 삭제나 개선 등의 방법으로 이루어진다.
	- 변경이 이루어지고 나면 부작용이 발생할 수 있기 때문에 필요함
	- 유지보수 릴리스는 범위에 따라 다양한 테스트 유형을 활용한 복수의 테스트 레벨에서의 유지보수 테스팅이 필요할 수 있다.

- 유지보수 테스팅의 범위에 영향을 끼치는 요소
	- 변경의 리스크 수준 (EX. 변경된 소프트웨어 영역이 다른 컴포넌트나 시스템과 통신하는 정도)
	- 기존 시스템의 규모
	- 변경의 규모

- 필요한 상황
	- 개선을 위한 변경
		- 계획된 확장, 수정, 긴급 변경, 운영환경 변경, 상용 소프트웨어 업그레이드, 결함 및 취약성을 위한 패치들
	- 이관을 위한 변경 [단종]
		- 단종, 애플리케이션 수명이 다할 때, 데이터 이관이나 장시간 데이터 유지가 필요할 경우 보관처리에 대한 테스팅 필요
		- 데이터의 복원/회수 절차에 대한 테스팅도 필요

## Q. 유지보수 테스팅에서 영향도 분석의 역할을 설명하시오
- 영향도 분석
	- 유지보수 릴리스에 포함된 변경을 평가
	- 의도한 결과뿐만 아니라 변경으로 인해 발생할 수 있는 예견된 부작용 식별
	- 변경의 영향을 받는 시스템의 영역을 식별하기 위해 실시
- 영향도 분석이 어려운 경우
	- 명세가 너무 오래됐거나 없는 경우
	- 테스트 케이스가 문서화되어 있지 않거나 너무 오래된 경우
	- 테스트와 테스트 베이시스 간 양방향 추적성이 유지되지 않은 경우
	- 도구 활용이 적거나 없는 경우
	- 연관된 인원이 도메인이나 시스템 지식을 가지고 있지 않은 경우
	- 소프트웨어 개발 중 유지보수성에 충분히 신경을 쓰지 못한 경우
